# Invoking the result() method of a Future blocks until the task completes (either by
# returning a value or by raising an exception) or is canceled. The results of multiple tasks
# can be accessed in the order the tasks were scheduled using map(). If the order in which the
# results should be processed does not matter, use as_completed() to process them as each
# task finishes.

# Because the pool has as many workers as tasks, all of the tasks can be started. They
# finish in a random order, so the values generated by as_completed() are different each time
# the example program runs.

from concurrent import futures
import random
import time

def task(n):
	time.sleep(random.random())
	return (n, n / 10)

ex = futures.ThreadPoolExecutor(max_workers=5)
print('main: starting')
wait_for = [
ex.submit(task, i)
for i in range(5, 0, -1)
]
for f in futures.as_completed(wait_for):
	print('main: result: {}'.format(f.result()))